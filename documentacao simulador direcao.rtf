{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1046{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\colortbl ;\red0\green0\blue255;}
{\*\generator Riched20 10.0.19041}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\f0\fs22\lang22 Jogo publicado: {{\field{\*\fldinst{HYPERLINK https://alfredo1995.github.io/simulador-direcao-unity }}{\fldrslt{https://alfredo1995.github.io/simulador-direcao-unity\ul0\cf0}}}}\f0\fs22\par
\par
<br>\par
\par
Aprendendo os fundamentos para cria\'e7\'e3o de Jogo em C# na unity atrav\'e9s da plataforma learn.unity    \par
    \par
    GameObjetos p/ representar os personagens, adere\'e7os e cen\'e1rios;\par
    Empyty GameObjects p/ organizar os objetos;\par
    Progamando o componente Script p/ ser posivel dirigir o veiculo pela estrada;\par
    Gerenciador de entrada "InputManager" p/ obter as teclas de entrada;\par
    Acessando o componente Transform do Veiculo, p/ determina suas Posi\'e7\'e3o, Rota\'e7\'e3o e Escala;\par
    Acessando o componente Translate, p/ definir a posi\'e7\'e3o ou mover um objeto;\par
    Acessando o cmponente Rotate, p/ girar o veiculo;\par
\par
\par
Primeiro passo, fa\'e7a o downloado do prototype 1 \par
\par
    {{\field{\*\fldinst{HYPERLINK https://connect-prd-cdn.unity.com/20210923/c709e76b-3e93-4140-8675-f694b9f04399/Prototype%201%20-%20Starter%20Files.zip }}{\fldrslt{https://connect-prd-cdn.unity.com/20210923/c709e76b-3e93-4140-8675-f694b9f04399/Prototype%201%20-%20Starter%20Files.zip\ul0\cf0}}}}\f0\fs22\par
    \par
Iniciando Projeto\par
    \par
    1) No desktop > criar uma nova pasta, em seguida, "nomeie-o a pasta";\par
\par
    2) Crie um novo projeto Unity usando o modelo 3D;\par
\par
    3) Selecione Criar e, em seguida, aguarde que a Unity abra seu novo projeto;\par
\par
\par
Importar ativos contendo os personagens e adere\'e7os\par
\par
    {{\field{\*\fldinst{HYPERLINK https://assetstore.unity.com/packages/3d/vehicles/land/arcade-free-racing-car-161085 }}{\fldrslt{https://assetstore.unity.com/packages/3d/vehicles/land/arcade-free-racing-car-161085\ul0\cf0}}}}\f0\fs22   \par
    \par
Prot\'f3tipo 1\par
\par
    1) Extraia a pasta compactada dos arquivos importados > clique para abrir o arquivo;\par
\par
    3) Na janela do Projeto, em  Assets > Scenes > Clique duplo na cena do Prot\'f3tipo 1 para abri-lo;\par
\par
    4) Assets > Scenes > seleecione a cena > prototype 1;\par
  \par
\par
Adicione seu ve\'edculo \'e0 cena\par
\par
    1) Na Janela do Projeto, abra os ativos > Biblioteca de Cursos > Ve\'edculos e arraste um ve\'edculo para a Hierarquia;      \par
    \par
    2) Com o ve\'edculo selecionado e seu mouse na vista da cena, pressione F para se concentrar nele;\par
    \par
\par
Adicione um obst\'e1culo e reposicione-o\par
\par
    1) V\'e1 para a Biblioteca de Cursos > Obst\'e1culos e arraste um obst\'e1culo diretamente para a vista da cena;\par
\par
    2) No Inspetor para o seu obst\'e1culo, no canto superior direito do componente Transformar, clique no bot\'e3o mais op\'e7\'f5es > Redefinir a posi\'e7\'e3o;    \par
\par
    3) No Inspetor, altere o Local XYZ para x=0, y=0, z=25;\par
\par
    4) Na hierarquia, clique com o bot\'e3o direito do mouse > renomeie seus dois objetos como "Ve\'edculo" e "Obst\'e1culo";\par
\par
Localize sua c\'e2mera e execute o jogo\par
\par
    1) Selecione a c\'e2mera na hierarquia e pressione F para se concentrar nela;    \par
\par
    2) Mova a c\'e2mera para tr\'e1s do ve\'edculo;\par
\par
    3) Use as  ferramentas Move and Rotate para mover a c\'e2mera atr\'e1s do ve\'edculo olhando para baixo sobre ele;   \par
    \par
Crie e aplique o primeiro script\par
 \par
    0) Todos os GameObject s\'e3o composto por componentes;\par
    \par
    1) Na janela Do projeto, criei uma pasta chamada "Scripts"\par
    \par
    2) Na pasta "Scripts", clique com o bot\'e3o direito do mouse > Criar >C# Script chamado "PlayerController" \par
    \par
    3) Arraste o novo script para o objeto Do ve\'edculo;\par
    \par
    4) Clique no objeto do ve\'edculo p/ ter certeza de que foi adicionado como um componente no Inspetor\par
    \par
D\'ea ao ve\'edculo um movimento para a frente\par
\par
    1) clique duplo no script > Metodo update do objeto veiculo, alterar o componente de trasforma\'e7\'e3o;    \par
\par
    void Update()\par
    \{\par
        transform.Translate(0, 0, 1);\par
    \} \par
\par
\par
Debugando o codigo acima p/ alterar o componente de trasnforma\'e7\'e3o\par
    \par
    1) um "T" minusculo signigica que estamos recebendo um componente de trasforma\'e7\'e3o / veiculo transform;\par
    \par
    2) Utilizando o metodo Translate para mudar a posi\'e7\'e3o. Movimentar o veiculo na dire\'e7\'e3o z;\par
    \par
    3) Acessando a propriedade do metodo Translate, para mudar a posi\'e7\'e3o pelo eixos X, Y e Z;\par
    \par
    4) Adicionado 0 no eixo X para que o veiculo n\'e3o movar para direita ou esquerda;\par
    \par
    5) Adicionado 0 no eixo Y para que o veiculo n\'e3o movar para cima ou abaixo;\par
    \par
    6) Adicionado 1 no eixo Z para que o veiculo mova na dire\'e7\'e3o Z;\par
\par
Use um Vector3 para seguir em frente, alterando o codigo do componente de trasnforma\'e7\'e3o\par
\par
    1) Excluir o 0, 0, 1 para substitu\'ed-lo por Vector3.forward;\par
    \par
    \par
        void Update()\par
    \{\par
        transform.Translate(Vector3.forward);\par
    \}\par
    \par
Debugando altera\'e7\'e3o no codigo do componente de trasnforma\'e7\'e3o\par
\par
    1) Vector3 \'e9 um tipo de vari\'e1vel composto por 3 componentes "(x,y,z)";\par
    \par
    2) basicamente serve para guardar 3 valores, um valor para cada um de seus componentes; \par
    \par
    3) Um Vector3 \'e9 comumente usado para guardar ou setar posi\'e7\'f5es dos objetos no espa\'e7o 3D;\par
    \par
    4) .forward \'e9 o pra frente do objeto no script;\par
\par
Personalize a velocidade do ve\'edculo\par
\par
    1) mudar a maneira com que movemos o veiculo;\par
    \par
    2) usar o simbolo * para multiplicamos;  \par
    \par
    2) usar o Time. para manter o controle do nosso tempo em vez de frame;    \par
    \par
    4) usar .deltaTime para obter a mudan\'e7a no tempo e assim saber quanto tempo se passou;\par
    \par
    5) multiplicar * 20 para aumentar a velocidade do veiculo no jogo;\par
  \par
  \par
    void Update()\par
    \{\par
        transform.Translate(Vector3.forward * Time.deltaTime * 20);\par
\par
    \}\par
    \par
Adicione componentes rigidbody aos objetos\par
    \par
    0) RigidBody \'e9 um componente que, quando adicionado a um objeto, habilita for\'e7as f\'edsicas a atuarem sobre ele;\par
\par
    1) Selecione o Ve\'edculo e, em seguida, na hierarquia clique em Adicionar componente e selecione RigidBody;\par
    \par
    2) Selecione o Obst\'e1culo e, em seguida, na hierarquia clique em Adicionar componente e selecione RigidBody;\par
    \par
    3) Nas propriedades do componente RigidBody, aumente a massa de ve\'edculos p/ 100 e obst\'e1culos p/ 2 assim eles est\'e3o em quilogramas;\par
    \par
    4) Mesh Collider sao os nossos caminho como o que esses objetos podem ser colididos;\par
    \par
    \par
Duplicar e posicionar os obst\'e1culos\par
\par
    1) Clique e em seu obst\'e1culo a janela de hierarquia;\par
    \par
    2) Pressione Ctrl/Cmd+D para duplicar o obst\'e1culo e mov\'ea-lo para baixo do eixo Z;     \par
\par
Adicione uma vari\'e1vel de velocidade para o seu ve\'edculo\par
\par
    0) vamos criar uma nova variavel "speed" para definimos a velocidade do veiculo nessa variavel;\par
    \par
    1) essa variavel vai ser capaz de alterar o * 20 que esta sendo multiplicado pelo tempo;\par
    \par
    2) No PlayerController.cs, atribua a velocidade de flutua\'e7\'e3o p\'fablica  = 5,0f;  no topo da classe\par
    \par
   \par
        Public class PlayController : Monobehaviour \{\par
\par
        float speed = 5.0f;\par
        \par
        \par
    3) assim onde tem o 20 que esta sendo multiplicado pelo tempo;\par
        \par
    4) vamos substuir o valor da velocidade de 20 pela nossa variavel "speed" para alterar a velocidade do veiculo; \par
        \par
        void Update()\par
        \{\par
            transform.Translate(Vector3.forward * Time.deltaTime * speed);\par
\par
        \}        \par
                             \par
\par
Crie um novo script para a c\'e2mera\par
\par
    1) Crie um novo script C# chamado FollowPlayer e conecte-o \'e0 c\'e2mera;\par
    \par
    2) Clique no script FollowPlayer e arraste para dentro da hieraquia "Main Camera";\par
    \par
    3) Clique duplo no script FollowPlayer para ser aberto no visual studio;\par
    \par
    4) vamos criar um variavel publica do tipo GameObject que sirva de referencia para nosso player(veiculo) com a Main Camera\par
    \par
        public class FollowPlayer : MonoBehaviour\par
        \{\par
            public GameObject player;        \par
        \par
    5) No unity selecione a "Main Camera" > no componente de script > vai visualizar a variavel Player contendo > None(GameObject)\par
    \par
    6) Vamos refernciar o nosso veiculo, clicando na pasta "Veiculo" arrastando pra dentro do componente da "Main Camera" > Nome(GameObject);\par
    \par
    7) Agora a variavel player esta referenciado o veiculo;\par
    \par
    8) Vamos obter a transforma\'e7\'e3o da posi\'e7\'e3o da camera no metodo update atribuindo a referencia player\par
    \par
    9) vamos acersar o compornente de trasnforma\'e7\'e3o do player player.transform e obter a posi\'e7\'e3o\par
    \par
           void Update()\par
            \{\par
                transform.position = player.transform.position;\par
            \}\par
    \par
    10) Agora a posi\'e7\'e3o da c\'e2mera ser\'e1 definido para posi\'e7\'e3o atual do player(veiculo)        \par
    \par
Adicione um deslocamento \'e0 posi\'e7\'e3o da c\'e2mera\par
    \par
    0) Vamos compensar a c\'e2mera atr\'e1s do player, adicionado a posi\'e7\'e3o do player;\par
\par
    1) Script FollowPlayer.cs no metodo update onde estamos definindo a posi\'e7\'e3o da nossa camera(transform.position);    \par
    \par
    2) Na linha no m\'e9todo 'criar' um novo Vector3(0, 5, -7), ser\'e1 criado um novo Vector3 apenas para essa linha de codigo;\par
    \par
    3) o novo Vector3 tera nas respectivas posi\'e7\'f5es ( X = 0, Y = 5 e Z = -7);\par
    \par
            void Update()\par
            \{\par
                transform.position = player.transform.position + new Vector3(0, 5, -7);\par
            \}\par
       \par
       \par
Fa\'e7a o deslocamento em uma vari\'e1vel Vector3\par
\par
    1) Vamos criar uma variavel Vector3 e assim remover os valores codificado ( X = 0, Y = 5 e Z = -7);\par
    \par
    2) No topo do FollowPlayer.cs, declare deslocamento privado do Vector3; \par
    \par
    3) Vamos declarar uma variavel do tipo Vector3 e chama-la de "offset";\par
    \par
    4) vamos definir esta variavel para ser o valor codificado ( X = 0, Y = 5 e Z = -7);\par
    \par
    5) vamos remover os valores codificado new Vector3(0, 5, -7);\par
    \par
    6) defini uma variavel do tipo vector3 chamada "offset", atribuindo o novo vector3 que sera responsavel pela inicializa\'e7\'e3o  \par
\par
\par
            public class FollowPlayer : MonoBehaviour\par
            \{\par
                public GameObject player;\par
                private Vector3 offset = new Vector3(0, 5, -7);\par
            \}\par
            \par
    7) agora nossa variavel vetorial esta sendo definida para o novo vector3 com nossa posi\'e7\'e3o de deslocamento adicionada a ele\par
    \par
    8) Agora no metodo Update, substitua o c\'f3digo original pela vari\'e1vel do tipo vector "offset";   \par
    \par
            void Update()\par
            \{\par
                transform.position = player.transform.position + offset;\par
            \}\par
            \par
       \par
Deixe o ve\'edculo mover-se para a esquerda/direita\par
\par
    0) Input e o sistema de entrada do unity, quando for precionado a seta para cima, voc\'ea recebe um valor de entrada(+1);\par
           Quando for preciosado as setas, voc\'ea recebe um valor de entrada de (+1) ou (-1) depedendo da dire\'e7\'e3o;           \par
                \par
    1) No topo do PlayerController.cs, adicione uma vari\'e1vel p\'fablica TurnSpeed para contralamos a movimenta\'e7\'e3o do veiculo;\par
           \par
                public class PlayerController : MonoBehaviour\par
\par
\par
                \{\par
                    public float speed = 10.0f;\par
                    public float turnSpeed;\par
\par
            \par
    2) vamos acessar o componete de transforma\'e7\'e3o do player para conseguimos obter a movimenta\'e7\'e3o no metodo update;\par
         \par
    3) transform > acessar a posi\'e7\'e3o; tranlate > modificar a moviementa\'e7\'e3o; Vector3 > composto por 3 componentes "(x,y,z)"; e .righ para move; \par
         \par
    4) * Time.deltaTime > para atualizar essa posi\'e7\'e3o ao longo do tempo em vez a cada frame(quadro);\par
         \par
    5) * turnSpeed > multiplicando pela variavel criada para acessar a movimenta\'e7\'e3o; \par
         \par
                void Update()\par
                \{\par
                    transform.Translate(Vector3.forward * Time.deltaTime * speed);\par
                    transform.Translate(Vector3.right * Time.deltaTime * turnSpeed);\par
                \}\par
         \par
Movimento base esquerda/direita na entrada\par
\par
    1) No menu superior, clique em Editar > Configura\'e7\'f5es do Projeto, input manager >  fold-out dos Eixos para explorar as entradas;\par
    \par
    2) No PlayerController.cs, adicione uma nova  vari\'e1vel de flutua\'e7\'e3o p\'fablica "horizontalInput" p/ pegar o valor de entrada;\par
    \par
            public class PlayerController : MonoBehaviour\par
\par
            \{\par
                public float speed = 10.0f;\par
                public float turnSpeed;\par
                public float horizontalInput;\par
    \par
    3) Definir essa vaiavel no metodo Update, atribuir o valor usando o gerenciado de entrada Input. > acessando o metodo de eixo GetAxis();    \par
    \par
    4) em Unity, em nosso input manager, o nome do nosso eixto \'e9 "Horizontal";\par
    \par
           void Update()\par
            \{\par
                horizontalInput = Input.GetAxis("Horizontal");\par
    \par
    5) Adicionar a vari\'e1vel horizontalInput ao m\'e9todo translate para obter o controle do ve\'edculo multiplicado pelo speedTurn;\par
    \par
           void Update()\par
            \{\par
                horizontalInput = Input.GetAxis("Horizontal");\par
\par
                transform.Translate(Vector3.forward * Time.deltaTime * speed);\par
                transform.Translate(Vector3.right * Time.deltaTime * turnSpeed * horizontalInput);\par
    \par
    6) No Unity, No Veiculo Inspetor, edite os valores das vari\'e1veis turnSpeed e speed para ajustar a sensa\'e7\'e3o de velocidade;\par
    \par
Assuma o controle da velocidade do ve\'edculo\par
\par
    1) Metodo Update > forwardInput atribuindo ao gerente de entrada input. acessando o metodo GetAxis() informando o eixo que ser\'e1 usado;\par
    \par
            void Update()\par
            \{\par
                horizontalInput = Input.GetAxis("Horizontal");\par
                forwardnInput = Input.GetAxis("Vertical");\par
    \par
    4) Adicione a vari\'e1vel forwardInput ao m\'e9todo translate para a frente multiplicado com o speed;\par
    \par
            void Update()\par
            \{                \par
                forwardnInput = Input.GetAxis("Vertical");\par
                horizontalInput = Input.GetAxis("Horizontal");\par
\par
                transform.Translate(Vector3.forward * Time.deltaTime * speed * forwardnInput);\par
                transform.Translate(Vector3.right * Time.deltaTime * turnSpeed * horizontalInput);\par
                \par
Fa\'e7a o ve\'edculo girar em vez de deslizar\par
\par
    1) metodo Update, chamar trasform acessando o metodo de rota\'e7\'e3o > transform.Rotate > e acessar Vector3. up pegando o calculo do angulo(turnSpeed);\par
    \par
    2) O angula ja foi calculado em: transform.Translate(Vector3.right * Time.deltaTime * turnSpeed * horizontalInput);\par
    \par
    3) vamos recotar esse trecho de codigo: Time.deltaTime * turnSpeed * horizontalInput\par
    \par
    4) Adicionar ao transform.Rotate(Vector3.up, > \par
\par
            transform.Rotate(Vector3.up, Time.deltaTime * turnSpeed * horizontalInput);\par
    \par
Exclua o c\'f3digo q estava caluclundo o angulo com turnSpeed > transform.Translate(Vector3.right * Time.deltaTime * turnSpeed * horizontalInput);\par
            \par
            void Update()\par
            \{\par
                horizontalInput = Input.GetAxis("Horizontal");\par
                forwardnInput = Input.GetAxis("Vertical");\par
\par
                transform.Translate(Vector3.forward * Time.deltaTime * speed * forwardnInput);\par
                transform.Rotate(Vector3.up, Time.deltaTime * turnSpeed * horizontalInput);\par
    \par
\par
Inicialize vari\'e1veis com valores no PlayerController > public float turnSpeed = 50.0f;\par
    \par
    \par
   \par
   \par
   \par
   \par
   \par
   \par
   \par
   \par
   \par
   \par
    \par
    \par
    \par
<br> <br>\par
\par
\par
\par
\par
\par
programando um jogo de corredor de rolagem lateral sem fim em ritmo acelerado ou jogo runner(corrida infininta), onde o jogador precisa de saltar sobre obst\'e1culos que se aproximam para evitar bater. \par
\par
\par
Principais Conceitos e Habilidades\par
\par
        GetComponent\par
        ForceMode.Impulse\par
        F\'edsica.Gravidade\par
        Restri\'e7\'f5es r\'edgidas do corpo\par
        Vari\'e1veis rigidbody\par
        Booleanos\par
        Multiplicar/Atribuir ("*) Operador\par
        E (&&) Operador\par
        OnCollisionEnter()\par
\par
        Repetir o plano de fundo\par
        Obter largura collider\par
        Comunica\'e7\'e3o de script\par
        Igual a (==) operador\par
        Tags\par
        CompareTag()\par
        \par
        Controladores de anima\'e7\'e3o\par
        Estados de anima\'e7\'e3o, camadas e transi\'e7\'f5es\par
        Par\'e2metros de anima\'e7\'e3o\par
        Programa\'e7\'e3o de anima\'e7\'e3o\par
        SetTrigger(), SetBool(), SetInt()\par
        N\'e3o (!) operador\par
        \par
        Sistemas de part\'edculas \par
        Posicionamento do objeto infantil\par
        Clipes de \'e1udio e fontes de \'e1udio \par
        Reproduzir e parar os efeitos sonoros\par
<br>\par
\par
Abrir prot\'f3tipo e alterar fundo\par
\par
        1) Abra o Unity Hub e crie um projeto vazio de "Prot\'f3tipo 3" em seu diret\'f3rio de curso na vers\'e3o unity correta.\par
        \par
        2) Clique para baixar o Prot\'f3tipo 3 Starter Files, extrair a pasta compactada e, em seguida, importar o .unitypackage em seu projeto. \par
        \par
        3) Abra a cena do Prot\'f3tipo 3 e exclua a Cena da Amostra sem salvar\par
        \par
        4) Selecione o objeto De fundo na hierarquia e, em seguida, no  componente Sprite Renderer > Sprite, selecione a imagem _City, _Nature ou _Town\par
\par
Escolha e configure um personagem do jogador\par
\par
        1) Da Biblioteca de Curso > Personagens, Arraste um personagem para a hierarquia, renomeie-o  "Jogador", \par
           em seguida, gire-o no eixo Y para enfrentar \'e0 direita\par
           \par
        2) Adicione um  componente do corpo RigBody     \par
        \par
        3) Adicione um colisor de caixa e, em seguida, edite os limites do colisor\par
        \par
        4) Crie uma nova pasta "Scripts" em Ativos, crie um script "PlayerController" dentro e conecte-o ao jogador\par
        \par
Fa\'e7a o jogador saltar no in\'edcio\par
\par
        1) No PlayerController.cs, declare um novo playerrb r\'edgido privado;  vari\'e1vel\par
        \par
        2) Em Start(), inicialize playerRb = GetComponent<Rigidbody>();\par
        \par
        3) Em Start(), use o m\'e9todo AddForce para fazer o jogador saltar no in\'edcio do jogo\par
        \par
                public class PlayerController : MonoBehaviour\par
                \{\par
                    private Rigidbody PlayerRb;\par
                    void Start()\par
                    \{\par
                        PlayerRb = GetComponent<Rigidbody>();\par
                        PlayerRb.AddForce(Vector3.up * 500);\par
                    \}\par
\par
Fa\'e7a o jogador saltar se a barra espacial pressionar\par
\par
        1) Em Atualiza\'e7\'e3o() adicione uma instru\'e7\'e3o if-then verificando se a barra de espa\'e7o est\'e1 pressionada\par
        \par
        2) Corte e cole o c\'f3digo AddForce do Start() na instru\'e7\'e3o if\par
        \par
        3) Adicione o  par\'e2metro ForceMode.Impulse \'e0  chamada AddForce e, em seguida, reduza  o valor do multiplicador de for\'e7a\par
        \par
                    void Update()\par
                    \{\par
                        if (Input.GetKeyUp(KeyCode.Space))\par
                        \{\par
                            PlayerRb.AddForce(Vector3.up * 10, ForceMode.Impulse);\par
                        \}\par
                    \}\par
                \}\par
                \par
Ajuste a for\'e7a de salto e a gravidade\par
\par
        1) Substitua o valor codificado por uma nova  vari\'e1vel p\'fablica de salto flutuante\par
\par
        2) Adicione uma nova  vari\'e1vel de gravidade flutuante p\'fablicaModifier e em Start(), \par
           adicione F\'edsica.gravidade *= gravityModifier; \par
        \par
        3) No inspetor, ajuste os valores de massa gravityModifier, jumpForce e Rigibody \par
        \par
                public class PlayerController : MonoBehaviour\par
                \{\par
                    public float jumpForce = 10.0f;\par
                    public float gravityModifier;\par
                    void Start()\par
                    \{\par
                        PlayerRb = GetComponent<Rigidbody>();\par
                        Physics.gravity *= gravityModifier;\par
                    \}\par
\par
                    void Update()\par
                    \{\par
                        if (Input.GetKeyUp(KeyCode.Space))\par
                        \{\par
                            PlayerRb.AddForce(Vector3.up * jumpForce, ForceMode.Impulse);\par
                        \}\par
                    \}\par
                \}\par
\par
Evite que o jogador pule duas vezes\par
\par
        1) Adicione uma nova vari\'e1vel  de bool isOnGround p\'fablico e defina-a igual a verdade\par
        \par
        2) Na declara\'e7\'e3o se fazendo o jogador saltar, definir isOnGround = false,\par
        \par
        3) Adicione uma condi\'e7\'e3o && isOnGround \'e0 declara\'e7\'e3o if ( && = e , para que haja mais uma afirma\'e7\'e3o)\par
        \par
        4) Adicione um novo metodo vazio OnCollisionEnter, definir isOnGround = verdadeiro nesse m\'e9todo\par
        \par
        5) quando o player estiver no chao = true , quando nao tiver = false\par
        \par
                public class PlayerController : MonoBehaviour\par
                \{\par
                    public bool isOnGround = true;\par
                    \par
                    void Update()\par
                    \{\par
                        if (Input.GetKeyUp(KeyCode.Space) && isOnGround)\par
                        \{\par
                            PlayerRb.AddForce(Vector3.up * jumpForce, ForceMode.Impulse);\par
                            isOnGround = false; \par
                        \}\par
                    \}\par
\par
                    private void OnCollisionEnter(Collision collision)\par
                    \{\par
                        isOnGround = true;\par
\par
                    \}\par
                \}\par
                \par
Fa\'e7a um obst\'e1culo e mova-o para a esquerda\par
\par
            1) Da Biblioteca de Curso > Obst\'e1culos, adicione um obst\'e1culo, renomeie-o como "Obst\'e1culo", e  posicione-o onde deve desovar\par
            \par
            2) Aplique um  componente r\'edgido do colisor de corpo e caixa e, em seguida, edite os limites do colisor para se encaixar no obst\'e1culo\par
            \par
            3) Crie uma nova pasta "Prefabs" e arraste-a para criar um novo Prefab original\par
            \par
            4) Crie um novo script "MoveLeft",  aplique-o ao obst\'e1culo e  abra-o para dar o efeito "parallax"\par
            \par
            5) Em MoveLeft.cs, escreva o c\'f3digo para traduzi-lo para a esquerda de acordo com a \par
               vari\'e1vel de velocidade. Aplique o script MoveLeft ao fundo(background)\par
               \par
                    public class MoveLeft : MonoBehaviour\par
                    \{\par
                        public float speed = 10.0f;\par
                        void Start()\par
                        \{\par
\par
                        \}\par
\par
                        void Update()\par
                        \{\par
                            transform.Translate(Vector3.left * Time.deltaTime * speed);  \par
                        \}\par
                    \}\par
                    \par
Crie um gerenciador de desova\par
\par
        1) Crie um novo objeto vazio "Spawn Manager" e aplique um novo  script .cs SpawnManager a ele\par
\par
        2) Em SpawnManager.cs, declare um novo obst\'e1culo p\'fablico do GameObjectPrefab; , em seguida, \par
           atribua seu pr\'e9-fabricado \'e0 nova vari\'e1vel no inspetor\par
\par
        3) Declare um novo vetor3 privado spawnPos em seu local de desova\par
        \par
        4) In Start(), Instanciar um novo pr\'e9-fabricado de obst\'e1culos \par
        \par
        \par
                public class SpawnManager : MonoBehaviour\par
                \{\par
                    public GameObject obstaclePrefabs;\par
                    private Vector3 spawnPosition = new Vector3(25, 0, 0);\par
                    void Start()\par
                    \{\par
                        Instantiate(obstaclePrefabs, spawnPosition, obstaclePrefabs.transform.rotation);\par
                    \}\par
                    \par
Gerar obst\'e1culos em intervalos\par
\par
        1) Crie um novo  m\'e9todo de desobstaculo de vazio e, em seguida, mova a  chamada Instantiate dentro dele\par
\par
        2) Crie novas vari\'e1veis flutuantes para iniciarDelay e repetirRate\par
\par
        3) Que seus obst\'e1culos desovam em intervalos usando o  m\'e9todo InvokeRepeating()\par
\par
        4) No componente Do corpo r\'edgido do jogador, expanda as restri\'e7\'f5es e congele  tudo, menos a posi\'e7\'e3o Y\par
        \par
                public class SpawnManager : MonoBehaviour\par
                \{\par
                    public GameObject obstaclePrefabs;\par
                    private Vector3 spawnPosition = new Vector3(25, 0, 0);\par
                    private float startDelay = 2.0f;\par
                    private float repeatRate = 2.0f;\par
                    void Start()\par
                    \{\par
                        InvokeRepeating("spawObstacle", startDelay, repeatRate);\par
                    \}\par
\par
                    void spawObstacle()\par
                    \{\par
                        Instantiate(obstaclePrefabs, spawnPosition, obstaclePrefabs.transform.rotation);\par
\par
                    \}\par
                \}\par
\par
<br>\par
\par
Principais Conceitos e Habilidades modulo 1\par
\par
        GetComponent\par
        ForceMode.Impulse\par
        F\'edsica.Gravidade\par
        Restri\'e7\'f5es r\'edgidas do corpo\par
        Vari\'e1veis rigidbody\par
        Booleanos\par
        Multiplicar/Atribuir ("*) Operador\par
        E (&&) Operador\par
        OnCollisionEnter()\par
        \par
<br>\par
\par
Crie um script para repetir o plano de fundo\par
    \par
        Crie um novo script chamado RepeatBackground.cs e conecte-o ao objeto de fundo\par
        \par
Redefinir posi\'e7\'e3o de fundo\par
\par
        1) Declarar uma nova vari\'e1vel private Vector3 startPos;\par
\par
        2) Em Start(), defina a  vari\'e1vel startPos \'e0 sua posi\'e7\'e3o inicial real atribuindo-a  = transform.position;\par
\par
        3) Em Update(), escreva uma posi\'e7\'e3o if-statement para redefinir se ela mover uma certa dist\'e2ncia\par
\par
                public class RepeatBackground : MonoBehaviour\par
                \{\par
                    private Vector3 startPos;\par
                    void Start()\par
                    \{\par
                        startPos = transform.position;\par
                    \}\par
\par
                    void Update()\par
                    \{\par
                        if(transform.position.x < startPos.x -50)\par
                        \{\par
                            transform.position = startPos;\par
                        \}\par
                    \}\par
                \}\par
\par
Corrigir repeti\'e7\'e3o de fundo com colisor\par
\par
        1) Adicione um  componente collider de  caixa ao fundo\par
\par
        2) Declare uma nova  vari\'e1vel de repeti\'e7\'e3o de flutua\'e7\'e3o privada\par
\par
        3) Em Start(), obtenha a largura do colisor de caixa, dividido por 2\par
\par
        4) Incorpore a  vari\'e1vel repeti\'e7\'e3oWidth na fun\'e7\'e3o repeti\'e7\'e3o\par
\par
                public class RepeatBackground : MonoBehaviour\par
                \{\par
                    private Vector3 startPos;\par
                    private float reapetWidth;\par
                    void Start()\par
                    \{\par
                        startPos = transform.position;\par
                        reapetWidth = GetComponent<BoxCollider>().size.x / 2;\par
                    \}\par
\par
                    void Update()\par
                    \{\par
                        if(transform.position.x < startPos.x - reapetWidth)\par
                        \{\par
                            transform.position = startPos;\par
                        \}\par
                    \}\par
                \}\par
\par
\par
Adicione um novo jogo sobre o gatilho\par
\par
        1) No inspetor, adicione uma tag "Ground" ao ch\'e3o e uma tag "Obst\'e1culo" ao pr\'e9-fio de obst\'e1culo\par
\par
        2) No PlayerController, declare um novo jogo p\'fablico boolOver;\par
\par
        3) Em OnCollisionEnter, adicione a instru\'e7\'e3o if-else para testar se o jogador colidiu com o "Ground" ou um "Obst\'e1culo"\par
\par
        4) Se eles colidiram com o "Ground", set isOnGround = verdadeiro, e se colidirem com um "Obst\'e1culo", definir gameOver = verdadeiro        \par
        \par
                public class PlayerController : MonoBehaviour\par
                \{\par
                    public bool gameOver = false;\par
                    \par
                    private void OnCollisionEnter(Collision collision)\par
                    \{\par
                        if (collision.gameObject.CompareTag("Ground"))\par
                        \{\par
                            isOnGround = true;\par
                        \}\par
                        else if (collision.gameObject.CompareTag("Obstacle"))\par
                        \{\par
                            gameOver = true;\par
                            Debug.Log("Game Over");\par
                        \}\par
\par
                    \}\par
                \}\par
                \par
Stop MoveLeft no gameOver\par
\par
        1) Em MoveLeft.cs, declare um novo player privado PlayerControllerScript;\par
\par
        2) In Start(), inicialize-o encontrando o Jogador e recebendo o componente PlayerController\par
\par
        3) Enrole o m\'e9todo de tradu\'e7\'e3o em uma verifica\'e7\'e3o se o jogo n\'e3o acabou\par
        \par
                public class MoveLeft : MonoBehaviour\par
                \{\par
                    private float speed = 10.0f;\par
                    private PlayerController playControllerScript;\par
                    \par
                    void Start()\par
                    \{\par
                        playControllerScript = GameObject.Find("Player").GetComponent<PlayerController>();\par
                    \}\par
\par
                    void Update()\par
                    \{\par
                        if(playControllerScript.gameOver == false)\par
                        \{\par
                            transform.Translate(Vector3.left * Time.deltaTime * speed);\par
\par
                        \}\par
                    \}\par
                \}\par
     \par
 <br>    \par
 \par
Conceitos desse modulo 2\par
 \par
        Repetir o plano de fundo\par
        Obter largura collider\par
        Comunica\'e7\'e3o de script\par
        Igual a (==) operador\par
        Tags\par
        CompareTag()\par
        \par
 <br>       \par
 \par
Explore as anima\'e7\'f5es do jogador\par
\par
        Clique duas vezes no Controlador de Anima\'e7\'e3o do Jogador e, em seguida, \par
        explore as diferentes camadas, clicando duas vezes em Estados para ver suas anima\'e7\'f5es \par
        e transi\'e7\'f5es para ver suas condi\'e7\'f5es\par
\par
\par
Fa\'e7a o jogador come\'e7ar em uma corrida\par
\par
        1) Na guia Par\'e2metros, altere a  vari\'e1vel Speed_f para 1.0\par
\par
        2) Clique com o bot\'e3o direito do mouse no Run_Static > Set como Estado padr\'e3o da camada\par
\par
        3) Clique em um \'fanico o estado Run_Static e ajuste o  valor de velocidade no inspetor para corresponder \'e0 velocidade do fundo\par
\par
\par
Configure uma anima\'e7\'e3o de salto\par
\par
        1) No PlayerController.cs, declare um novo jogador privado de AnimatorAnim; \par
        \par
        2) In Start(), set playerAnim = GetComponent<Animator>();\par
\par
        3) Na declara\'e7\'e3o if para quando o jogador saltar, acione o salto: playerAnim. SetTrigger ("Jump_trig");\par
        \par
        \par
                public class PlayerController : MonoBehaviour\par
                \{\par
                    private Rigidbody PlayerRb;\par
                    private Animator PlayerAnim;\par
\par
                    void Start()\par
                    \{\par
                        PlayerRb = GetComponent<Rigidbody>();\par
                        PlayerAnim = GetComponent<Animator>();\par
                    \}\par
\par
                    void Update()\par
                    \{\par
                        if (Input.GetKeyUp(KeyCode.Space) && isOnGround)\par
                        \{\par
                            PlayerRb.AddForce(Vector3.up * jumpForce, ForceMode.Impulse);\par
                            isOnGround = false;\par
                            PlayerAnim.SetTrigger("Jump_trig");\par
                        \}\par
                    \}\par
\par
\par
\par
Ajuste a anima\'e7\'e3o de salto\par
\par
        1) Na janela animador, clique no estado Running_Jump, depois no inspetor e reduza seu valor de velocidade para 0.7\par
\par
        2) Ajuste a massa do jogador, a for\'e7a de salto e  o modificador de gravidade para acertar o seu salto\par
        \par
        3) player > rigbody > mass > 60, jump force 700, Gravity Modified 1.5;\par
        \par
\par
Configure uma anima\'e7\'e3o em queda PlayerController\par
\par
        1) Na condi\'e7\'e3o de que o jogador colide com Obst\'e1culo, definir a morte bool para a verdade\par
        \par
        2) Na mesma declara\'e7\'e3o se, defina o inteiro DeathType para 1 \par
\par
                private void OnCollisionEnter(Collision collision)\par
                \{\par
                    else if (collision.gameObject.CompareTag("Obstacle"))\par
                    \{\par
                        gameOver = true;\par
                        Debug.Log("Game Over");\par
                        PlayerAnim.SetBool("Death_b", true);\par
                        PlayerAnim.SetInteger("DeathType_int", 1);\par
                    \}\par
\par
Impedir o jogador de pular inconsciente PlayController\par
\par
        1) Para evitar que o jogador pule inconsciente, adicione && !gameOver \'e0 condi\'e7\'e3o de salto \par
        \par
                void Update()\par
                \{\par
                    if (Input.GetKeyUp(KeyCode.Space) && isOnGround && !gameOver)\par
                    \{\par
                        PlayerRb.AddForce(Vector3.up * jumpForce, ForceMode.Impulse);\par
                        isOnGround = false;\par
                        PlayerAnim.SetTrigger("Jump_trig");\par
                    \}\par
                    \par
<br>\par
\par
Conceitos de modulo 3\par
\par
        Controladores de anima\'e7\'e3o\par
        Estados de anima\'e7\'e3o, camadas e transi\'e7\'f5es\par
        Par\'e2metros de anima\'e7\'e3o\par
        Programa\'e7\'e3o de anima\'e7\'e3o\par
        SetTrigger(), SetBool(), SetInt()\par
        N\'e3o (!) operador\par
        \par
 <br>\par
 \par
Adicione uma part\'edcula de respingo de sujeira\par
\par
        1) Da  Biblioteca de curso > Part\'edculas, arraste FX_DirtSplatter para o player\par
\par
        2) Declarar uma nova sujeira do Sistema de Part\'edculas p\'fablicas; , em seguida,  atribu\'ed-lo no Inspetor\par
        \par
        3) Adicionar dirtParticle.Stop();  quando o jogador pula ou colide com um obst\'e1culo\par
        \par
        4) Adicionar dirtParticle.Play();  quando o jogador pousa no ch\'e3o\par
        \par
                public ParticleSystem dirParticle\par
\par
                void Update () \{\par
                        if (Input.GetKeyUp(KeyCode.Space) && isOnGround && !gameOver)\{\par
                                dirtParticle.Stop();  \}\}\par
\par
                private void OnCollisionEnter(collision collision other)\{\par
                        if (collision.gameObject.CompareTag("Ground"))\{\par
\par
                         dirParticle.Play();\par
\par
                        else if (collision.gameObject.CompareTag("Obstacle"))\par
                                            dirtParticle.Stop();  \}\}\par
\par
    \par
Adicione m\'fasica ao objeto da c\'e2mera\par
  \par
        1) Selecione o  objeto da c\'e2mera principal  e, em seguida, adicione componente > \'e1udio source\par
        \par
        2) Na Biblioteca de Curso > Sound, arraste um clipe de m\'fasica para a  vari\'e1vel AudioClip no inspetor\par
        \par
        3) Reduza o volume para que seja mais f\'e1cil ouvir efeitos sonoros\par
        \par
Declare vari\'e1veis para clipes de \'e1udio\par
\par
        1) No PlayerController.cs, declare um novo v\'eddeo p\'fablico do AudioClip;  e um novo \'e1udioclip p\'fablico crashSound;\par
\par
        2) Na Biblioteca de Curso > Som, arraste um clipe para cada nova  vari\'e1vel de som no inspetor\par
        \par
Reproduzir clipes de \'e1udio no salto e acidente\par
\par
        1) Adicione um  componente de fonte de \'e1udio ao player\par
        \par
        2) Declare um novo player audiosource privadoAudio;  e inicializ\'e1-lo como playerAudio = GetComponent<AudioSource>();\par
\par
        3) Ligue para o playerAudio.PlayOneShot(jumpSound, 1.0f);  quando o personagem pula\par
\par
        4) Ligue para o playerAudio.PlayOneShot(crashSound, 1.0f);  quando o personagem trava\par
        \par
        \par
                public class PlayerController : MonoBehaviour\par
                \{\par
                    private AudioSource PlayerAudio;\par
\par
                    void Start()\par
                    \{\par
                        PlayerAudio = GetComponent<AudioSource>();\par
                    \}\par
\par
                    void Update()\par
                    \{\par
                        if (Input.GetKeyUp(KeyCode.Space) && isOnGround && !gameOver)\par
                        \{\par
                            PlayerAudio.PlayOneShot(jumpSound, 1.0f);\par
                        \}\par
                    \}\par
\par
                    private void OnCollisionEnter(Collision collision)\par
                    \{\par
                        else if (collision.gameObject.CompareTag("Obstacle"))\par
                        \{\par
                            gameOver = true;\par
                            PlayerAudio.PlayOneShot(crashSound, 1.0f);\par
                        \}\par
\par
\par
Novos Conceitos e Habilidades modulo 4\par
\par
        Sistemas de part\'edculas \par
        Posicionamento do objeto infantil\par
        Clipes de \'e1udio e fontes de \'e1udio \par
        Reproduzir e parar os efeitos sonoros\par
}
 